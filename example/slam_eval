#!/usr/bin/python
# slam_eval -- evaluates SLAM data set in relation to the ground truth
# Copyright (C) 2014  Galois, Inc.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
#   1. Redistributions of source code must retain the above copyright notice,
#      this list of conditions and the following disclaimer.
#   2. Redistributions in binary form must reproduce the above copyright notice,
#      this list of conditions and the following disclaimer in the documentation
#      and/or other materials provided with the distribution.
#   3. Neither Galois's name nor the names of other contributors may be used to
#      endorse or promote products derived from this software without specific
#      prior written permission.
#
# THIS SOFTWARE IS PROVIDED BY GALOIS AND OTHER CONTRIBUTORS "AS IS" AND ANY
# EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
# WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
# DISCLAIMED.  IN NO EVENT SHALL GALOIS OR OTHER CONTRIBUTORS BE LIABLE FOR ANY
# DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
# (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
# LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
# ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
# (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
# SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

import csv
import optparse
import os
import sys

import numpy as np


################################ Reading data #################################

def read_slam_csv(raw):
    dialect = csv.Sniffer().sniff(raw.read(1024))
    raw.seek(0)
    reader = csv.reader(raw, dialect)
    processed = set()
    for x_str, y_str in list(reader)[1:]: # drop header
        processed.add((float(x_str), float(y_str)))
    return processed

def read_result(path):
    with open(os.path.join(path, "slam_out_landmarks.csv"), 'rb') as raw:
        return read_slam_csv(raw)

def read_ground(path):
    with open(os.path.join(path, "obstacles.csv"), 'rb') as raw:
        return read_slam_csv(raw)


################################# Evaluation ##################################

def gaussian2(a, bx, by, c, x, y):
    return a * np.exp(-(np.sqrt((x-bx)**2 + (y-by)**2)) / (2*c*c))

def map_pointset(points, x_range, y_range, width):
    xs, ys = np.meshgrid(x_range, y_range)
    (npts, _junk) = points.shape
    result = np.zeros(xs.shape)
    for i in xrange(0, npts):
        result = np.maximum(result,
                            gaussian2(1.0,
                                      points[i,0], points[i,1],
                                      width,
                                      xs, ys))
    return result

def map_metric(points1, points2, x_range, y_range, width):
    map1 = map_pointset(points1, x_range, y_range, width)
    map2 = map_pointset(points2, x_range, y_range, width)
    return np.sum(np.abs(map1 - map2))

def compare(result, ground):
    # How many extra points were found?
    n_extras = np.abs(len(result) - len(ground))
    # How close were the found points?
    score = map_metric(np.array(list(result)), np.array(list(ground)),
                       np.arange(-5, 5, 0.1), np.arange(-5, 5, 0.1),
                       1.0)
    return (n_extras, score)


#################################### Main #####################################

def read_cli():
    parser = optparse.OptionParser(
        usage="Usage: %prog result ground_truth output")
    _options, args = parser.parse_args()
    if len(args) != 3:
        parser.print_usage()
        sys.exit(1)
    else:
        return args

def main():
    result_path, ground_path, output_path = read_cli()
    result = read_result(result_path)
    ground = read_ground(ground_path)
    with open(output_path, 'w') as output:
        output.writelines(str(val) + '\n' for val in compare(result, ground))

if __name__ == '__main__':
    main()
