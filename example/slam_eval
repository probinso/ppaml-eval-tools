#!/usr/bin/python
# slam_eval -- evaluates SLAM data set in relation to the ground truth
# Copyright (C) 2014  Galois, Inc.
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or (at
# your option) any later version.
#
# This program is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
# General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# To contact Galois, complete the Web form at
# <http://corp.galois.com/contact/> or write to Galois, Inc., 421
# Southwest 6th Avenue, Suite 300, Portland, Oregon, 97204-1622.

import csv
import optparse
import os
import sys

import numpy as np


################################ Reading data #################################

def read_slam_csv(raw):
    dialect = csv.Sniffer().sniff(raw.read(1024))
    raw.seek(0)
    reader = csv.reader(raw, dialect)
    processed = set()
    for x_str, y_str in list(reader)[1:]: # drop header
        processed.add((float(x_str), float(y_str)))
    return processed

def read_result(path):
    with open(os.path.join(path, "slam_out_landmarks.csv"), 'rb') as raw:
        return read_slam_csv(raw)

def read_ground(path):
    with open(os.path.join(path, "obstacles.csv"), 'rb') as raw:
        return read_slam_csv(raw)


################################# Evaluation ##################################

def gaussian2(a, bx, by, c, x, y):
    return a * np.exp(-(np.sqrt((x-bx)**2 + (y-by)**2)) / (2*c*c))

def map_pointset(points, x_range, y_range, width):
    xs, ys = np.meshgrid(x_range, y_range)
    (npts, _junk) = points.shape
    result = np.zeros(xs.shape)
    for i in xrange(0, npts):
        result = np.maximum(result,
                            gaussian2(1.0,
                                      points[i,0], points[i,1],
                                      width,
                                      xs, ys))
    return result

def map_metric(points1, points2, x_range, y_range, width):
    map1 = map_pointset(points1, x_range, y_range, width)
    map2 = map_pointset(points2, x_range, y_range, width)
    return np.sum(np.abs(map1 - map2))

def compare(result, ground):
    # How many extra points were found?
    n_extras = np.abs(len(result) - len(ground))
    # How close were the found points?
    score = map_metric(np.array(list(result)), np.array(list(ground)),
                       np.arange(-5, 5, 0.1), np.arange(-5, 5, 0.1),
                       1.0)
    return (n_extras, score)


#################################### Main #####################################

def read_cli():
    parser = optparse.OptionParser(
        usage="Usage: %prog result ground_truth output")
    _options, args = parser.parse_args()
    if len(args) != 3:
        parser.print_usage()
        sys.exit(1)
    else:
        return args

def main():
    result_path, ground_path, output_path = read_cli()
    result = read_result(result_path)
    ground = read_ground(ground_path)
    with open(output_path, 'w') as output:
        output.writelines(str(val) + '\n' for val in compare(result, ground))

if __name__ == '__main__':
    main()
